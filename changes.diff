Only in ../spring/rts/lib/lua: CMakeLists.txt
Only in ../spring/rts/lib/lua: README_SPRING
Only in ../spring/rts/lib/lua/include: LuaInclude.h
Only in ../spring/rts/lib/lua/include: LuaUser.cpp
Only in ../spring/rts/lib/lua/include: LuaUser.h
diff -ru lua-5.1.5-spring/include/lauxlib.h ../spring/rts/lib/lua/include/lauxlib.h
--- lua-5.1.5-spring/include/lauxlib.h	2025-05-24 16:39:36.711634054 +0200
+++ ../spring/rts/lib/lua/include/lauxlib.h	2025-05-24 13:18:40.608449232 +0200
@@ -52,6 +52,7 @@
 LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                           const char *def, size_t *l);
 LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
+LUALIB_API lua_Number (luaL_checknumber_noassert) (lua_State *L, int numArg);
 LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
 
 LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
diff -ru lua-5.1.5-spring/include/lua.h ../spring/rts/lib/lua/include/lua.h
--- lua-5.1.5-spring/include/lua.h	2025-05-24 16:39:37.033643907 +0200
+++ ../spring/rts/lib/lua/include/lua.h	2025-05-24 13:18:40.608449232 +0200
@@ -103,6 +103,25 @@
 typedef LUA_INTEGER lua_Integer;
 
 
+/* type for string hashes */
+typedef unsigned int lua_Hash;
+
+
+/*
+** SPRING additions for io access security
+*/
+#include <stdio.h>
+typedef FILE* (*lua_Func_fopen)(lua_State* L, const char* path, const char* mode);
+typedef FILE* (*lua_Func_popen)(lua_State* L, const char* command, const char* type);
+typedef int   (*lua_Func_pclose)(lua_State* L, FILE* stream);
+typedef int   (*lua_Func_system)(lua_State* L, const char* command);
+typedef int   (*lua_Func_remove)(lua_State* L, const char* pathname);
+typedef int   (*lua_Func_rename)(lua_State* L, const char* oldpath, const char* newpath);
+LUA_API void lua_set_fopen(lua_State* L, lua_Func_fopen);
+LUA_API void lua_set_popen(lua_State* L, lua_Func_popen, lua_Func_pclose);
+LUA_API void lua_set_system(lua_State* L, lua_Func_system);
+LUA_API void lua_set_remove(lua_State* L, lua_Func_remove);
+LUA_API void lua_set_rename(lua_State* L, lua_Func_rename);
 
 /*
 ** state manipulation
@@ -243,6 +262,10 @@
 LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
 LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
 
+//SPRING
+LUA_API lua_Hash (lua_calchash) (const char *s, size_t l);
+LUA_API void  (lua_pushhstring) (lua_State *L,
+                                 lua_Hash h, const char *s, size_t l);
 
 
 /* 
diff -ru lua-5.1.5-spring/include/luaconf.h ../spring/rts/lib/lua/include/luaconf.h
--- lua-5.1.5-spring/include/luaconf.h	2025-05-24 16:39:38.535689865 +0200
+++ ../spring/rts/lib/lua/include/luaconf.h	2025-05-24 13:18:40.608449232 +0200
@@ -508,8 +508,10 @@
 ** ===================================================================
 */
 
-#define LUA_NUMBER_DOUBLE
-#define LUA_NUMBER	double
+//SPRING#define LUA_NUMBER_DOUBLE
+//SPRING#define LUA_NUMBER	double
+#undef LUA_NUMBER_DOUBLE
+#define LUA_NUMBER	float
 
 /*
 @@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@@ -525,10 +527,16 @@
 @@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
 @@ lua_str2number converts a string to a number.
 */
-//SPRING#define LUA_NUMBER_SCAN
-#define LUA_NUMBER_SCAN                "%f"
+//SPRING#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_SCAN		"%f"
 #define LUA_NUMBER_FMT		"%.14g"
+#ifndef BUILDING_AI
+#define lua_number2str(s,n)	spring_lua_ftoa((n),(s))
+#define lua_number2fmt(s,fmt,n)	spring_lua_format((n), (fmt), (s))
+#else
 #define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
+#define lua_number2fmt(s,fmt,n)	sprintf((s), fmt, (n))
+#endif
 #define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
 #define lua_str2number(s,p)	strtod((s), (p))
 
@@ -543,7 +551,7 @@
 #define luai_numsub(a,b)	((a) - (b))
 #define luai_nummul(a,b)	((a) * (b))
 #define luai_numdiv(a,b)	((a) / (b))
-#define luai_nummod(a,b)	((a) -  math::floor((a) / (b))*(b))
+#define luai_nummod(a,b)	((a) - math::floor(luai_numdiv((a), (b))) * (b))
 #define luai_numpow(a,b)	(math::pow((a), (b)))
 #define luai_numunm(a)		(-(a))
 #define luai_numeq(a,b)		((a) == (b))
@@ -566,23 +574,24 @@
 #if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
     (defined(__i386) || defined (_M_IX86) || defined(__i386__))
 
-/* On a Microsoft compiler, use assembler */
-#if defined(_MSC_VER)
-
-#define lua_number2int(i,d)   __asm fld d   __asm fistp i
-#define lua_number2integer(i,n)		lua_number2int(i, n)
-
-/* the next trick should work on any Pentium, but sometimes clashes
-   with a DirectX idiosyncrasy */
-#else
-
-union luai_Cast { double l_d; long l_l; };
-#define lua_number2int(i,d) \
-  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
-#define lua_number2integer(i,n)		lua_number2int(i, n)
+	/* On a Microsoft compiler, use assembler */
+	#if defined(_MSC_VER)
 
-#endif
+		#warning Using ASM for lua_number2int  (SPRING)
+		#define lua_number2int(i,d)   __asm fld d   __asm fistp i
+		#define lua_number2integer(i,n)		lua_number2int(i, n)
+
+		/* the next trick should work on any Pentium, but sometimes clashes
+		with a DirectX idiosyncrasy */
+	#else
+
+		#warning Using casting for lua_number2int  (SPRING)
+		union luai_Cast { double l_d; long l_l; };
+		#define lua_number2int(i,d) \
+		{ volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
+		#define lua_number2integer(i,n)		lua_number2int(i, n)
 
+	#endif
 
 /* this option always works, but may be slow */
 #else
@@ -729,13 +738,30 @@
 ** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
 ** extra when a thread is created/deleted/resumed/yielded.
 */
-#define luai_userstateopen(L)		((void)L)
-#define luai_userstateclose(L)		((void)L)
-#define luai_userstatethread(L,L1)	((void)L)
-#define luai_userstatefree(L)		((void)L)
-#define luai_userstateresume(L,n)	((void)L)
-#define luai_userstateyield(L,n)	((void)L)
-
+//SPRING
+#define ENABLE_USERSTATE_LOCKS 0
+#ifndef BUILDING_AI
+	#define LUA_USER_H "LuaUser.h"
+	#define luai_userstateopen(L)		LuaCreateMutex(L)
+	#define luai_userstateclose(L)		LuaDestroyMutex(L)
+	#define luai_userstatethread(L,L1)	LuaLinkMutex(L,L1)
+	#define luai_userstatefree(L)		LuaDestroyMutex(L)
+	#define luai_userstateresume(L,n)	((void)L)
+	#define luai_userstateyield(L,n)	((void)L)
+	// Don't use internal locking system yet, cause it makes _each_ c++ call to a lua function safe.
+	// But not a group of them, so it's possible that multiple threads modify the stack of a single lua_State and breaking each other.
+	// Solution might be to use coroutines for each c++ thread, cause they got their own stacks and so cannot break each other.
+	//#define luai_userstateyield(L,n)	LuaMutexYield(L)
+	#define lua_lock(L)			LuaMutexLock(L)
+	#define lua_unlock(L)			LuaMutexUnlock(L)
+#else
+	#define luai_userstateopen(L)		((void)L)
+	#define luai_userstateclose(L)		((void)L)
+	#define luai_userstatethread(L,L1)	((void)L)
+	#define luai_userstatefree(L)		((void)L)
+	#define luai_userstateresume(L,n)	((void)L)
+	#define luai_userstateyield(L,n)	((void)L)
+#endif
 
 /*
 @@ LUA_INTFRMLEN is the length modifier for integer conversions
Only in ../spring/rts/lib/lua: lua_history.txt
Only in ../spring/rts/lib/lua: patch-lua-5.1.4-2.diff
diff -ru lua-5.1.5-spring/src/lapi.cpp ../spring/rts/lib/lua/src/lapi.cpp
--- lua-5.1.5-spring/src/lapi.cpp	2025-05-24 16:39:37.241650271 +0200
+++ ../spring/rts/lib/lua/src/lapi.cpp	2025-05-24 13:18:40.608449232 +0200
@@ -452,6 +452,17 @@
 }
 
 
+//SPRING
+LUA_API void lua_pushhstring (lua_State *L,
+                              lua_Hash h, const char *s, size_t len) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  setsvalue2s(L, L->top, luaS_newhstr(L, h, s, len));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
 LUA_API void lua_pushstring (lua_State *L, const char *s) {
   if (s == NULL)
     lua_pushnil(L);
@@ -1086,3 +1097,38 @@
   return name;
 }
 
+
+/* SPRING syscall additions */
+LUA_API void lua_set_fopen(lua_State* L, lua_Func_fopen func) {
+  G(L)->fopen_func = func;
+}
+
+
+LUA_API void lua_set_popen(lua_State* L, lua_Func_popen popen_func,
+                                         lua_Func_pclose pclose_func) {
+  if (popen_func && pclose_func) {
+    G(L)->popen_func  = popen_func;
+    G(L)->pclose_func = pclose_func;
+  } else {
+    G(L)->popen_func  = NULL;
+    G(L)->pclose_func = NULL;
+  }
+}
+
+
+LUA_API void lua_set_system(lua_State* L, lua_Func_system func) {
+  G(L)->system_func = func;
+}
+
+
+LUA_API void lua_set_remove(lua_State* L, lua_Func_remove func) {
+  G(L)->remove_func = func;
+}
+
+
+LUA_API void lua_set_rename(lua_State* L, lua_Func_rename func) {
+  G(L)->rename_func = func;
+}
+/* END SPRING syscall additions */
+
+
diff -ru lua-5.1.5-spring/src/lauxlib.cpp ../spring/rts/lib/lua/src/lauxlib.cpp
--- lua-5.1.5-spring/src/lauxlib.cpp	2025-05-24 16:39:38.216680104 +0200
+++ ../spring/rts/lib/lua/src/lauxlib.cpp	2025-05-24 13:18:40.608449232 +0200
@@ -179,6 +179,25 @@
   lua_Number d = lua_tonumber(L, narg);
   if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
     tag_error(L, narg, LUA_TNUMBER);
+
+#if defined(REPORT_LUANAN)
+  // SPRING
+  //   this is used by luaL_optnumber, luaL_optfloat (via luaL_optnumber),
+  //   and luaL_checkfloat, so the asserts should cover 90% of all cases
+  //   in which non-numbers can infect the engine -- lua_tofloat asserts
+  //   take care of the rest
+  if unlikely(math::isinf(d)) luaL_argerror(L, narg, "number expected, got +-Inf (check your code for div0)");
+  if unlikely(math::isnan(d)) luaL_argerror(L, narg, "number expected, got +-NaN (check your code for div0)");
+#endif
+
+  return d;
+}
+
+LUALIB_API lua_Number luaL_checknumber_noassert (lua_State *L, int narg) {
+  lua_Number d = lua_tonumber(L, narg);
+  if (d == 0 && !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+
   return d;
 }
 
diff -ru lua-5.1.5-spring/src/lbaselib.cpp ../spring/rts/lib/lua/src/lbaselib.cpp
--- lua-5.1.5-spring/src/lbaselib.cpp	2025-05-24 16:39:36.710634023 +0200
+++ ../spring/rts/lib/lua/src/lbaselib.cpp	2025-05-24 13:18:40.608449232 +0200
@@ -235,11 +235,23 @@
 }
 
 
+/*** 
+ * Meta <code>__pairs</code> backported from Lua 5.2,
+ * originally <code>lua_pushvalue(L, lua_upvalueindex(1)); </code> was <code>lua_pushcfunction(L, luaB_next);</code>
+ * <br>
+ * but that requires "light C function" support,
+ * which makes lua_pushcfunction not allocate extra memory for the GC to clean up.
+ */
 static int luaB_pairs (lua_State *L) {
-  luaL_checktype(L, 1, LUA_TTABLE);
-  lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
-  lua_pushvalue(L, 1);  /* state, */
-  lua_pushnil(L);  /* and initial value */
+  luaL_checkany(L, 1);
+  if (luaL_getmetafield(L, 1, "__pairs") == LUA_TNIL) {  /* no metamethod? */
+    lua_pushvalue(L, lua_upvalueindex(1));  /* return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    lua_pushnil(L);  /* and initial value */
+  } else {
+    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
+    lua_call(L, 1, 3);  /* get 3 values from metamethod */
+  }
   return 3;
 }
 
@@ -410,9 +422,21 @@
     case LUA_TNIL:
       lua_pushliteral(L, "nil");
       break;
+    /*
+     * SPRING - synced safety change
+     */
+    case LUA_TNONE:          { lua_pushliteral(L, "<none>");          break; }
+    case LUA_TTABLE:         { lua_pushliteral(L, "<table>");         break; }
+    case LUA_TUSERDATA:      { lua_pushliteral(L, "<userdata>");      break; }
+    case LUA_TLIGHTUSERDATA: { lua_pushliteral(L, "<lightuserdata>"); break; }
+    case LUA_TFUNCTION:      { lua_pushliteral(L, "<function>");      break; }
+    case LUA_TTHREAD:        { lua_pushliteral(L, "<thread>");        break; }
+    default:                 { lua_pushliteral(L, "<unknown_type>");  break; }
+/*
     default:
       lua_pushfstring(L, "%s: %p", luaL_typename(L, 1), lua_topointer(L, 1));
       break;
+*/
   }
   return 1;
 }
diff -ru lua-5.1.5-spring/src/liolib.cpp ../spring/rts/lib/lua/src/liolib.cpp
--- lua-5.1.5-spring/src/liolib.cpp	2025-05-24 16:39:38.211679951 +0200
+++ ../spring/rts/lib/lua/src/liolib.cpp	2025-05-23 17:51:52.396227960 +0200
@@ -28,6 +28,17 @@
 static const char *const fnames[] = {"input", "output"};
 
 
+/* SPRING */
+static FILE* lua_fopen(lua_State* L, const char* filename, const char* mode)
+{
+  if (G(L)->fopen_func) {
+    return G(L)->fopen_func(L, filename, mode);
+  }
+  errno = EIO; /* why not? */
+  return NULL;
+}
+
+
 static int pushresult (lua_State *L, int i, const char *filename) {
   int en = errno;  /* calls to Lua API may change this value */
   if (i) {
diff -ru lua-5.1.5-spring/src/lmathlib.cpp ../spring/rts/lib/lua/src/lmathlib.cpp
--- lua-5.1.5-spring/src/lmathlib.cpp	2025-05-24 16:39:38.217680135 +0200
+++ ../spring/rts/lib/lua/src/lmathlib.cpp	2025-05-24 13:18:40.609449262 +0200
@@ -23,7 +23,6 @@
 #define RADIANS_PER_DEGREE math::DEG_TO_RAD //SPRING(PI/180.0)
 
 
-
 static int math_abs (lua_State *L) {
   lua_pushnumber(L, math::fabs(luaL_checknumber_noassert(L, 1)));
   return 1;
@@ -95,10 +94,24 @@
 }
 
 static int math_modf (lua_State *L) {
-  double ip;
-  double fp = modf(luaL_checknumber_noassert(L, 1), &ip);
-  lua_pushnumber(L, ip);
-  lua_pushnumber(L, fp);
+  // FIXME -- streflop does not have modf()
+  // double fp = math::modf(luaL_checknumber_noassert(L, 1), &ip);
+  const float in = (float)luaL_checknumber_noassert(L, 1);
+
+  if (math::isnan(in)) {
+    lua_pushnumber(L, in);
+    lua_pushnumber(L, in);
+  }
+  else if (math::isinf(in)) {
+    lua_pushnumber(L, in);
+    lua_pushnumber(L, 0.0f);
+  }
+  else {
+    const float fp = math::fmod(in, 1.0f);
+    const float ip = (in - fp);
+    lua_pushnumber(L, ip);
+    lua_pushnumber(L, fp);
+  }
   return 2;
 }
 
@@ -179,7 +192,9 @@
 }
 
 
+
 static int math_random (lua_State *L) {
+  #ifndef LUA_USER_H
   /* the `%' avoids the (rare) case of r==1, and is needed also because on
      some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
   lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
@@ -204,12 +219,18 @@
     default: return luaL_error(L, "wrong number of arguments");
   }
   return 1;
+  #else
+  return (spring_lua_unsynced_rand(L)); // SPRING
+  #endif
 }
 
-
 static int math_randomseed (lua_State *L) {
+  #ifndef LUA_USER_H
   srand(luaL_checkint(L, 1));
   return 0;
+  #else
+  return (spring_lua_unsynced_srand(L)); // SPRING
+  #endif
 }
 
 
@@ -253,7 +274,13 @@
   luaL_register(L, LUA_MATHLIBNAME, mathlib);
   lua_pushnumber(L, math::PI);
   lua_setfield(L, -2, "pi");
+  lua_pushnumber(L, math::TWOPI);
+  lua_setfield(L, -2, "tau");
+#if STREFLOP_ENABLED
+  lua_pushnumber(L, math::SimplePositiveInfinity); // streflop
+#else
   lua_pushnumber(L, HUGE_VAL);
+#endif
   lua_setfield(L, -2, "huge");
 #if defined(LUA_COMPAT_MOD)
   lua_getfield(L, -1, "fmod");
diff -ru lua-5.1.5-spring/src/loslib.cpp ../spring/rts/lib/lua/src/loslib.cpp
--- lua-5.1.5-spring/src/loslib.cpp	2025-05-24 16:39:38.213680012 +0200
+++ ../spring/rts/lib/lua/src/loslib.cpp	2025-05-24 13:18:40.609449262 +0200
@@ -37,21 +37,37 @@
 
 
 static int os_execute (lua_State *L) {
-  lua_pushinteger(L, system(luaL_optstring(L, 1, NULL)));
+  if (!G(L)->system_func) { /* SPRING */
+    lua_pushinteger(L, -1);
+  } else {
+    lua_pushinteger(L, G(L)->system_func(L, luaL_optstring(L, 1, NULL)));
+  }
   return 1;
 }
 
 
 static int os_remove (lua_State *L) {
   const char *filename = luaL_checkstring(L, 1);
-  return os_pushresult(L, remove(filename) == 0, filename);
+  if (!G(L)->remove_func) { /* SPRING */
+    lua_pushnil(L);
+    lua_pushliteral(L, "os.remove() is not available");
+    lua_pushnumber(L, 0);
+    return 3;
+  }
+  return os_pushresult(L, G(L)->remove_func(L, filename) == 0, filename);
 }
 
 
 static int os_rename (lua_State *L) {
   const char *fromname = luaL_checkstring(L, 1);
   const char *toname = luaL_checkstring(L, 2);
-  return os_pushresult(L, rename(fromname, toname) == 0, fromname);
+  if (!G(L)->rename_func) { /* SPRING */
+    lua_pushnil(L);
+    lua_pushliteral(L, "os.rename() is not available");
+    lua_pushnumber(L, 0);
+    return 3;
+  }
+  return os_pushresult(L, G(L)->rename_func(L, fromname, toname) == 0, fromname);
 }
 
 
@@ -71,9 +87,19 @@
   return 1;
 }
 
+//SPRING
+#ifndef BUILDING_AI
+#include "System/Misc/SpringTime.h"
+#endif
 
 static int os_clock (lua_State *L) {
-  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  //SPRING
+#ifndef BUILDING_AI
+  //Lua's used clock() ran too fast on some linux systems, so rely on spring_time instead
+  lua_pushnumber(L, spring_time::getelapsedtime().toSecsf());
+#else
+  lua_pushnumber(L, (lua_Number)clock()/(lua_Number)CLOCKS_PER_SEC);
+#endif
   return 1;
 }
 
@@ -203,14 +229,9 @@
 
 
 static int os_setlocale (lua_State *L) {
-  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
-                      LC_NUMERIC, LC_TIME};
-  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
-     "numeric", "time", NULL};
-  const char *l = luaL_optstring(L, 1, NULL);
-  int op = luaL_checkoption(L, 2, "all", catnames);
-  lua_pushstring(L, setlocale(cat[op], l));
-  return 1;
+  /* Locale can affect sync. For example, strings can be sorted differently.
+   * In some locales, the upper/lower case order is ABab and in others AaBb. */
+  return 0;
 }
 
 
diff -ru lua-5.1.5-spring/src/lstate.cpp ../spring/rts/lib/lua/src/lstate.cpp
--- lua-5.1.5-spring/src/lstate.cpp	2025-05-24 16:39:38.218680165 +0200
+++ ../spring/rts/lib/lua/src/lstate.cpp	2025-05-24 13:18:40.609449262 +0200
@@ -36,7 +36,7 @@
   lua_State l;
   global_State g;
 } LG;
-  
+
 
 
 static void stack_init (lua_State *L1, lua_State *L) {
@@ -186,6 +186,15 @@
   }
   else
     luai_userstateopen(L);
+
+  /* SPRING additions, default to disabled functions */
+  g->fopen_func  = NULL;
+  g->popen_func  = NULL;
+  g->pclose_func = NULL;
+  g->system_func = NULL;
+  g->remove_func = NULL;
+  g->rename_func = NULL;
+
   return L;
 }
 
diff -ru lua-5.1.5-spring/src/lstate.h ../spring/rts/lib/lua/src/lstate.h
--- lua-5.1.5-spring/src/lstate.h	2025-05-24 16:39:37.138647119 +0200
+++ ../spring/rts/lib/lua/src/lstate.h	2025-05-24 13:18:40.609449262 +0200
@@ -14,7 +14,6 @@
 #include "lzio.h"
 
 
-
 struct lua_longjmp;  /* defined in ldo.c */
 
 
@@ -91,6 +90,15 @@
   UpVal uvhead;  /* head of double-linked list of all open upvalues */
   struct Table *mt[NUM_TAGS];  /* metatables for basic types */
   TString *tmname[TM_N];  /* array with tag-method names */
+
+  //SPRING additions
+  lua_Func_fopen  fopen_func;
+  lua_Func_popen  popen_func;
+  lua_Func_pclose pclose_func;
+  lua_Func_system system_func;
+  lua_Func_remove remove_func;
+  lua_Func_rename rename_func;
+
 } global_State;
 
 
diff -ru lua-5.1.5-spring/src/lstring.cpp ../spring/rts/lib/lua/src/lstring.cpp
--- lua-5.1.5-spring/src/lstring.cpp	2025-05-24 16:39:38.615692313 +0200
+++ ../spring/rts/lib/lua/src/lstring.cpp	2025-05-24 13:18:40.609449262 +0200
@@ -72,13 +72,25 @@
 }
 
 
-TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
-  GCObject *o;
-  unsigned int h = lua_cast(unsigned int, l);  /* seed */
+//SPRING
+static inline lua_Hash calchash(const char *str, size_t l) {
+  lua_Hash h = lua_cast(unsigned int, l);  /* seed */
   size_t step = (l>>5)+1;  /* if string is too long, don't hash all its chars */
   size_t l1;
-  for (l1=l; l1>=step; l1-=step)  /* compute hash */
+  for (l1=l; l1>=step; l1-=step) {  /* compute hash */
     h = h ^ ((h<<5)+(h>>2)+lua_cast(unsigned char, str[l1-1]));
+  }
+  return h;
+}
+
+
+//SPRING
+LUA_API lua_Hash lua_calchash(const char *str, size_t l) {
+  return calchash(str, l);
+}
+
+TString *luaS_newhstr (lua_State *L, lua_Hash h, const char *str, size_t l) {
+  GCObject *o;
   for (o = G(L)->strt.hash[lmod(h, G(L)->strt.size)];
        o != NULL;
        o = o->gch.next) {
@@ -92,7 +104,8 @@
   return newlstr(L, str, l, h);  /* not found */
 }
 
-/*
+
+//SPRING
 TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
   GCObject *o;
   const lua_Hash h = calchash(str, l);
@@ -108,7 +121,6 @@
   }
   return newlstr(L, str, l, h);  /* not found */
 }
-*/
 
 
 Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
diff -ru lua-5.1.5-spring/src/lstring.h ../spring/rts/lib/lua/src/lstring.h
--- lua-5.1.5-spring/src/lstring.h	2025-05-24 16:39:36.711634054 +0200
+++ ../spring/rts/lib/lua/src/lstring.h	2025-05-23 17:51:52.397227990 +0200
@@ -26,6 +26,9 @@
 LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
 LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
 LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+//SPRING
+LUAI_FUNC TString *luaS_newhstr (lua_State *L,
+                                 lua_Hash h, const char *str, size_t l);
 
 
 #endif
diff -ru lua-5.1.5-spring/src/lstrlib.cpp ../spring/rts/lib/lua/src/lstrlib.cpp
--- lua-5.1.5-spring/src/lstrlib.cpp	2025-05-24 16:39:36.711634054 +0200
+++ ../spring/rts/lib/lua/src/lstrlib.cpp	2025-05-24 13:18:40.609449262 +0200
@@ -789,7 +789,9 @@
         }
         case 'e':  case 'E': case 'f':
         case 'g': case 'G': {
-          sprintf(buff, form, (double)luaL_checknumber(L, arg));
+	  // SPRING sprintf(buff, form, (double)luaL_checknumber(L, arg));
+	  // float2str in printf is desyncing (between windows & linux) we need to use our own syncing one
+	  lua_number2fmt(buff, form, luaL_checknumber(L, arg));
           break;
         }
         case 'q': {
diff -ru lua-5.1.5-spring/src/lvm.cpp ../spring/rts/lib/lua/src/lvm.cpp
--- lua-5.1.5-spring/src/lvm.cpp	2025-05-24 16:39:38.214680043 +0200
+++ ../spring/rts/lib/lua/src/lvm.cpp	2025-05-24 13:18:40.610449293 +0200
@@ -54,7 +54,26 @@
   else {
     char s[LUAI_MAXNUMBER2STR];
     lua_Number n = nvalue(obj);
-    lua_number2str(s, n);
+    // SPRING -- synced safety change
+    //        -- need a custom number formatter?
+    if (math::isfinite(n)) {
+      lua_number2str(s, n);
+    }
+    else {
+      if (math::isnan(n)) {
+        strcpy(s, "nan");
+      }
+      else {
+        const int inf_type = math::isinf(n);
+        if (inf_type == 1) {
+          strcpy(s, "+inf");
+        } else if (inf_type == -1) {
+          strcpy(s, "-inf");
+        } else {
+          strcpy(s, "weird_number");
+        }
+      }
+    } 
     setsvalue2s(L, obj, luaS_new(L, s));
     return 1;
   }
@@ -209,8 +228,14 @@
   size_t ll = ls->tsv.len;
   const char *r = getstr(rs);
   size_t lr = rs->tsv.len;
+  //SPRING
+  const size_t n = std::min(ll, lr) + 1;
+  //SPRING
   for (;;) {
-    int temp = strcoll(l, r);
+    //SPRING
+    //int temp = strcoll(l, r);
+    int temp = strncmp(l, r, n);
+    //SPRING
     if (temp != 0) return temp;
     else {  /* strings are equal up to a `\0' */
       size_t len = strlen(l);  /* index of first `\0' in both strings */
diff -ru lua-5.1.5-spring/src/lzio.cpp ../spring/rts/lib/lua/src/lzio.cpp
--- lua-5.1.5-spring/src/lzio.cpp	2025-05-24 16:39:36.710634023 +0200
+++ ../spring/rts/lib/lua/src/lzio.cpp	2025-05-24 13:18:40.610449293 +0200
@@ -22,10 +22,14 @@
   size_t size;
   lua_State *L = z->L;
   const char *buff;
+  if (z->eoz) return EOZ;
   lua_unlock(L);
   buff = z->reader(L, z->data, &size);
   lua_lock(L);
-  if (buff == NULL || size == 0) return EOZ;
+  if (buff == NULL || size == 0) {
+    z->eoz = 1;  /* avoid calling reader function next time */
+    return EOZ;
+  }
   z->n = size - 1;
   z->p = buff;
   return char2int(*(z->p++));
@@ -51,6 +55,7 @@
   z->data = data;
   z->n = 0;
   z->p = NULL;
+  z->eoz = 0;
 }
 
 
diff -ru lua-5.1.5-spring/src/lzio.h ../spring/rts/lib/lua/src/lzio.h
--- lua-5.1.5-spring/src/lzio.h	2025-05-24 16:39:36.807636992 +0200
+++ ../spring/rts/lib/lua/src/lzio.h	2025-05-24 13:18:40.610449293 +0200
@@ -59,6 +59,7 @@
   lua_Reader reader;
   void* data;			/* additional data */
   lua_State *L;			/* Lua state (for reader) */
+  int eoz;			/* true if reader has no more data */
 };
 
 
